//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"text/template"
)

const versionsFileName string = "version.go"

var tmpl = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package migrations

const (
	LatestVersion uint32 = {{.Latest}} // Latest available migration version
)

var availableVersions = []uint32{
{{- range $ver := .All }}
	{{ $ver }},
{{- end }}
}

// AvailableVersions returns a slice with all available migration versions, ordered from lowest to highest.
func AvailableVersions() []uint32 { return availableVersions }
`),
)

func main() {
	buf, versions := new(bytes.Buffer), make([]uint32, 0)

	if err := filepath.Walk(".", func(path string, _ os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if strings.HasSuffix(path, ".up.sql") {
			if parts := strings.Split(path, "_"); len(parts) >= 1 {
				if ver, parsingErr := strconv.ParseUint(parts[0], 10, 32); parsingErr == nil {
					versions = append(versions, uint32(ver))
				} else {
					return parsingErr
				}
			}
		}

		return nil
	}); err != nil {
		log.Printf("Files walking error: %s\n", err)
	}

	sort.SliceStable(versions, func(i, j int) bool { return i < j })

	if len(versions) == 0 {
		log.Fatal("No versions found")
	}

	if err := tmpl.Execute(buf, struct {
		Latest uint32
		All    []uint32
	}{
		Latest: versions[len(versions)-1],
		All:    versions,
	}); err != nil {
		log.Fatalf("Error executing template: %s", err)
	}

	data, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Error formatting generated code: %s", err)
	}

	if err = ioutil.WriteFile(versionsFileName, data, 0666); err != nil {
		log.Fatalf("Error writing blob file: %s", err)
	}
}
